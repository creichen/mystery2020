import mystery2020.MType;
import mystery2020.MinMax;
import mystery2020.InvalidSubrangeException;

/**
 * General type assignment (independent of specific typing schemes)
 */
aspect Typing {

    syn MinMax Subrange.getMinMax() {
	return new MinMax(line(), Symbol.getColumn(this.getStart()),
			  MType.parseInt(line(), column(), this.getLower()),
			  MType.parseInt(line(), column(), this.getUpper()));
    }

    Subrange contributes (new InvalidSubrangeException(line(), "Invalid subrange"))
	when getMinMax().getMin() > getMinMax().getMax()
	to Program.generalStaticErrors();

    syn MType Type.getMType();

    eq UnknownType.getMType() = MType.ANY;
    eq IntType.getMType() = MType.INTEGER;
    eq SubrangeType.getMType() = MType.SUBRANGE(getSubrange().getMinMax());
    eq ArrayType.getMType() { throw new RuntimeException("Unsupported"); }
    eq NamedType.getMType() { throw new RuntimeException("Unsupported"); }
    eq UnitType.getMType() = MType.UNIT;
    eq ProcType.getMType() {
	MType[] args = new MType[this.getNumFormal()];
	MType ret = this.getType().getMType();
	for (int i = 0; i < this.getNumFormal(); ++i) {
	    args[i] = this.getFormal(i).getMType();
	}
	return MType.PROCEDURE(args, ret);
    }

    syn MType VarDecl.getMType();
    eq VarDecl.getMType() = getType().getMType();

    syn MType ProcDecl.getMType();
    eq ProcDecl.getMType() {
	MType[] args = new MType[this.getNumDecl()];
	MType ret = this.getType().getMType();
	for (int i = 0; i < this.getNumDecl(); ++i) {
	    args[i] = this.getDecl(i).getMType();
	}
	return MType.PROCEDURE(args, ret);
    }
}
