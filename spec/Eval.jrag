import beaver.Symbol;
import mystery2020.IntLiteralException;
import mystery2020.MType;
import mystery2020.runtime.Runtime;
import mystery2020.runtime.VariableVector;

/**
 * Expression evaluation
 */
aspect Eval {

    interface EvalInterface {
	Value eval(Runtime rt);
    }

    // ========================================
    // Declaration to value conversion
    Decl implements EvalInterface;

    public Value
    VarDecl.eval(Runtime rt) {
	return this.variable(rt).getValue();
    }

    public Value
    TypeDecl.eval(Runtime rt) {
	throw new mystery2020.InvalidVariableKindException(line(), "Trying to use type as a value: " + this.getName());
    }

    public Value
    ProcDecl.eval(Runtime rt) {
	return new Value(getMType(),
			 new Closure(this, rt.getStack().copyTruncated(this.staticNestingDepth())));
    }

    // ========================================
    // Expression evaluation
    Expr implements EvalInterface;

    public Value
    BinOpSequence.eval(Runtime rt) {
	throw new RuntimeException("Not supported; should have been rewritten");
    }

    public Value
    Number.eval(Runtime rt) {
	try {
	    Value v = new Value(MType.INTEGER, Integer.parseInt(this.getNumber()));
	    return v;
	} catch (NumberFormatException exn) {
	    throw new IntLiteralException(line(),
					  Symbol.getColumn(this.getStart()),
					  this.getNumber());
	}
    }

    public Value
    ID.eval(Runtime rt) {
	return rt.getDeclaration(this).eval(rt);
    }

    public Value
    Subscription.eval(Runtime rt) {
	throw new RuntimeException("FIXME-7"); // !!!!!!!!!!!!!!!
    }

    public Value
    Call.eval(Runtime rt) {
	rt.runCall(this);
	Value v = this.getCallee().eval(rt);
	VariableVector actuals = rt.prepareCallArguments(this.getActuals());
	return v.call(rt, line(), actuals);
    }

    public Value
    UnitValue.eval(Runtime rt) {
	// No idea why anyone has a reason to call this
	return Value.NOTHING;
    }

    // ========================================
    // Binary operator evaluation
    interface BinEvalInterface {
	Value bin_eval(Value lhs, EvalInterface rhs_closure, Runtime rt);
    }
    Operator implements BinEvalInterface;


    public Value
    BinOp.eval(Runtime rt) {
	Value result = this.getOperator().bin_eval(this.getLHS().eval(rt),
						   this.getRHS(),
						   rt);
	return result;
    }

    public Value
    AddOp.bin_eval(Value lhs, EvalInterface rhs_closure, Runtime rt) {
	long lhs_v = lhs.getInt(line());
	long rhs_v = rhs_closure.eval(rt).getInt(line());
	long result = lhs_v + rhs_v;
	int result_int = (int) result;
	if (result != result_int) {
	    // FIXME: optional error handling
	}
	return new Value(MType.INTEGER, result_int);
    }

    public Value
    GTOp.bin_eval(Value lhs, EvalInterface rhs_closure, Runtime rt) {
	int lhs_v = lhs.getInt(line());
	int rhs_v = rhs_closure.eval(rt).getInt(line());
	if (lhs_v > rhs_v) {
	    return True();
	}
	return False();
    }

    public Value
    EqOp.bin_eval(Value lhs, EvalInterface rhs_closure, Runtime rt) {
	if (lhs.equalTo(rhs_closure.eval(rt), config())) {
	    return True();
	}
	return False();

    }

    public Value
    AndOp.bin_eval(Value lhs, EvalInterface rhs_closure, Runtime rt) {
	int lhs_v = lhs.getInt(line());

	if (0 != lhs_v) {
	    // fixme: extract this one strictly if appropriate
	    int rhs_v = rhs_closure.eval(rt).getInt(line());

	    if (0 != rhs_v) {
		return True();
	    }
	}

	return False();
    }
}
