import beaver.Symbol;
import mystery2020.IntLiteralException;
import mystery2020.MType;
import mystery2020.runtime.Runtime;
import mystery2020.runtime.VariableVector;

/**
 * Expression evaluation
 */
aspect Eval {

    public interface EvalInterface {
	Value eval(Runtime rt);
    }

    // ========================================
    // Declaration to value conversion
    Decl implements EvalInterface;

    public Value
    VarDecl.eval(Runtime rt) {
	return this.variable(rt).getValue();
    }

    public Value
    TypeDecl.eval(Runtime rt) {
	throw new mystery2020.InvalidVariableKindException(line(), "Trying to use type as a value: " + this.getName());
    }

    public Value
    ProcDecl.eval(Runtime rt) {
	return new Value(getMType(rt),
			 new Closure(this, rt.getStack().copyTruncated(this.staticNestingDepth())));
    }

    // ========================================
    // Expression evaluation
    Expr implements EvalInterface;

    public Value
    BinOpSequence.eval(Runtime rt) {
	throw new RuntimeException("Not supported; should have been rewritten");
    }

    public Value
    Number.eval(Runtime rt) {
	try {
	    Value v = new Value(MType.INTEGER, Integer.parseInt(this.getNumber()));
	    return v;
	} catch (NumberFormatException exn) {
	    throw new IntLiteralException(line(),
					  Symbol.getColumn(this.getStart()),
					  this.getNumber());
	}
    }

    public Value
    ID.eval(Runtime rt) {
	return rt.getDeclaration(this).eval(rt);
    }

    public Value
    Subscription.eval(Runtime rt) {
	return this.variable(rt).getValue();
    }

    public Value
    Call.eval(Runtime rt) {
	rt.runCall(this);
	Value v = this.getCallee().eval(rt);
	VariableVector actuals = rt.prepareCallArguments(this.getActuals());
	return v.call(rt, line(), actuals);
    }

    public Value
    UnitValue.eval(Runtime rt) {
	// No idea why anyone has a reason to call this
	return Value.NOTHING;
    }

    // ========================================
    // Binary operator evaluation
    public class BinArguments {
	private Value lhs_value = null;
	private Value rhs_value = null;
	private EvalInterface lhs;
	private EvalInterface rhs;
	ASTNode origin;

	public BinArguments(ASTNode origin, EvalInterface lhs_in, EvalInterface rhs_in) {
	    this.origin = origin;
	    this.lhs = lhs_in;
	    this.rhs = rhs_in;
	}

	/**
	 * Evaluate arguments in the correct order
	 */
	public void
	prepare(Runtime rt) {
	    this.origin.config().operand_evaluation_order.get().prepare(this, rt);
	}

	public void
	evalLeft(Runtime rt) {
	    if (this.lhs_value == null) {
		this.lhs_value = this.lhs.eval(rt);
		this.lhs = null;
	    }
	}

	public void
	evalRight(Runtime rt) {
	    if (this.rhs_value == null) {
		this.rhs_value = this.rhs.eval(rt);
		this.rhs = null;
	    }
	}

	public Value
	getLHS(Runtime rt) {
	    this.evalLeft(rt);
	    return this.lhs_value;
	}

	public Value
	getRHS(Runtime rt) {
	    this.evalRight(rt);
	    return this.rhs_value;
	}
    }
    interface BinEvalInterface {
	Value bin_eval(BinArguments args, Runtime rt);
    }
    Operator implements BinEvalInterface;


    public Value
    BinOp.eval(Runtime rt) {
	Value result = this.getOperator().bin_eval(new BinArguments(this,
								    this.getLHS(),
								    this.getRHS()),
						   rt);
	return result;
    }

    public Value
    AddOp.bin_eval(BinArguments args, Runtime rt) {
	args.prepare(rt);
	long lhs_v = args.getLHS(rt).getInt(line());
	long rhs_v = args.getRHS(rt).getInt(line());
	long result = lhs_v + rhs_v;
	int result_int = (int) result;
	if (result != result_int) {
	    // FIXME: optional error handling
	}
	return new Value(MType.INTEGER, result_int);
    }

    public Value
    GTOp.bin_eval(BinArguments args, Runtime rt) {
	args.prepare(rt);
	int lhs_v = args.getLHS(rt).getInt(line());
	int rhs_v = args.getRHS(rt).getInt(line());
	if (lhs_v > rhs_v) {
	    return True();
	}
	return False();
    }

    public Value
    EqOp.bin_eval(BinArguments args, Runtime rt) {
	args.prepare(rt);
	Value lhs = args.getLHS(rt);
	if (lhs.equalTo(args.getRHS(rt), config())) {
	    return True();
	}
	return False();

    }

    public Value
    AndOp.bin_eval(BinArguments args, Runtime rt) {
	this.config().short_circuit_evaluation.get().preprocessArgs(args, rt);

	Value first = this.config().operand_evaluation_order.get().getValue(args, rt, true);
	int first_v = first.getInt(line());

	if (0 != first_v) {
	    int second_v = this.config().operand_evaluation_order.get().getValue(args, rt, false).getInt(line());

	    if (0 != second_v) {
		return True();
	    }
	}

	return False();
    }
}
