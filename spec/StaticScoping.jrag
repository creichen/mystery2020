import java.util.HashSet;
import java.util.LinkedList;
import mystery2020.NameException;

aspect StaticScoping {
    // ========================================
    // Name errors

    coll LinkedList<NameException> Program.nameErrors();

    Block contributes (new NameException(line(), "Ambiguous variable name: " + firstAmbiguousName()))
	when firstAmbiguousName() != null
	to Program.nameErrors();

    ProcDecl contributes (new NameException(line(), "Ambiguous formal parameter name: " + firstAmbiguousName()))
	when firstAmbiguousName() != null
	to Program.nameErrors();

    ID contributes (new NameException(line(), "Name not found: " + getName()))
	when declaration() == null
	to Program.nameErrors();

    static String
    Block.findAmbiguousParameterName(AbstractBlock block) {
	HashSet<String> names = new HashSet<>();
	for (Decl decl : block.getDecls()) {
	    String name = decl.name();
	    // FIXME: for now, everything always uses the same namespace
	    if (names.contains(name)) {
		return name;
	    }
	    names.add(name);
	}
	return null;
    }

    syn String ProcDecl.firstAmbiguousName() = Block.findAmbiguousParameterName(this);
    syn String Block.firstAmbiguousName() = Block.findAmbiguousParameterName(this);

    // ========================================
    // Vardecls and their immediate owners

    interface AbstractBlock {
	/**
	 * Whether this block represents a function argument list
	 */
	public boolean isArgs();

	public List<? extends Decl> getDecls();
    }
    ProcDecl implements AbstractBlock;
    Block implements AbstractBlock;

    public boolean ProcDecl.isArgs() { return true; }
    public boolean Block.isArgs() { return false; }

    inh int Decl.index();
    eq ProcDecl.getDecl(int index).index() = index;
    eq Block.getDecl(int index).index() = index;
    eq Call.getActual(int index).index() = index;

    // ========================================
    // Looking up Name Uses

    interface Named {
	public String name();
    }
    Decl implements Named;

    syn String Decl.name();
    eq VarDecl.name() = getName();
    eq TypeDecl.name() = getName();
    eq ProcDecl.name() = getName();

    syn Decl ID.declaration() {
	return lookupStatic(this.getName());
    }

    inh Decl AbstractBlock.lookupStatic(String name);
    inh Decl ID.lookupStatic(String name);

    eq Program.getBody().lookupStatic(String name) {
	return null;
    }

    eq ProcDecl.getBody().lookupStatic(String name) {
    	for (VarDecl decl : this.getDecls()) {
    	    if (decl.name().equals(name)) {
		return decl;
	    }
    	}
	System.err.println(parent.getClass());
    	return lookupStatic(name);
    }

    eq Block.getStmt().lookupStatic(String name) {
    	for (Decl decl : this.getDecls()) {
	    // FIXME: once we support multiple scopes, separate by type
    	    if (decl.name().equals(name)) {
		return decl;
	    }
    	}
    	return lookupStatic(name);
    }
}
